# Elixir / Rust 役割分担方針

**方針**: **苦手なものは Rust に投げる**

このドキュメントでは、Elixir × Rust ハイブリッドアーキテクチャにおける役割分担の方針をまとめます。

---

## 目次

1. [基本方針](#1-基本方針)
2. [得意・苦手の整理](#2-得意苦手の整理)
3. [タイミング精度について](#3-タイミング精度について)
4. [将来の拡張への対応方針](#4-将来の拡張への対応方針)
5. [やらなくていいもの](#5-やらなくていいもの)
6. [設計上の原則](#6-設計上の原則)

---

## 1. 基本方針

> **苦手なものは Rust に投げる**

- **Elixir が苦手とするもの**（低レイテンシ、厳密なタイミング、determinism）は **Rust に委譲する**
- **Rust が苦手とするもの**（分散、耐障害性、動的拡張）は **Elixir に任せる**
- 両者の強みを活かし、弱点を補い合う設計とする

この方針により、将来リズムゲームや競技マルチプレイなど、タイミングや determinism が重要なジャンルに対応する場合も、アーキテクチャを大きく変えずに拡張できる。

---

## 2. 得意・苦手の整理

| レイヤー | 得意なこと | 苦手なこと |
|----------|------------|------------|
| **Elixir** | 並行性、耐障害性、ホットリロード、分散、メッセージング、宣言的ロジック | 低レイテンシ、厳密なタイミング、determinism |
| **Rust** | 低レイテンシ、厳密なタイミング、determinism、直接的な制御 | 分散、耐障害性、動的拡張 |

### 現状の分担

| 担当 | 内容 |
|------|------|
| **Rust** | 物理演算、描画、音声、入力ポーリング、空間ハッシュ、SIMD、フリーリスト |
| **Elixir** | ゲームループ orchestration、ウェーブ制御、ボス管理、シーン管理、EventBus、Stats、Telemetry |

---

## 3. タイミング精度について

### 3.1 現状のジッター（±数 ms）の扱い

**60Hz ゲームループ**において、`Process.send_after/3` による ±数 ms のジッターは、**バレットヘル・サバイバー系では許容範囲**とする。

- プレイヤーの体感としては問題になりにくい
- ヒット判定の精度は「数フレーム分のずれ」で十分

### 3.2 ジッターが許容できないケース

以下のジャンル・機能では、より厳密なタイミングが必要となる可能性がある。

| ケース | 理由 |
|--------|------|
| **リズムゲーム** | ヒット判定のウィンドウが 20〜50 ms クラスで、判定精度がスコアに直結する |
| **競技系マルチプレイのロールバック** | フレーム単位の determinism が必要 |
| **TAS / リプレイの再現** | 同じ入力を同じ結果に結びつけるための厳密な再現性 |
| **音ゲー的な演出** | BGM/SE とゲームイベントのサブフレーム同期 |

### 3.3 対応方針

上記のケースに対応する場合、**タイミングクリティカルなパスを Rust に移す**。

- **現状**: Elixir が tick を開始（`Process.send_after` → `:tick` → `physics_step` NIF）
- **将来**: Rust が tick を主導（Rust 内で高精度タイマー、固定間隔で physics、イベントを Elixir に送信）

`main.rs` にスタンドアロン版があるため、そのループを拡張して Rust 主導モードを実装する形で対応可能。

---

## 4. 将来の拡張への対応方針

### 4.1 リズムゲーム（ヒット判定 20〜50 ms）

| 対応 | 内容 |
|------|------|
| **tick の主導権** | Rust に移す。Rust が高精度タイマー（`Instant` 等）で 16.67 ms ごとに tick |
| **physics / ヒット判定** | Rust 内で実行、Elixir には結果のみ渡す |
| **Elixir の役割** | スコア更新、UI、音声トリガーなど、タイミングに鈍感な部分 |

### 4.2 競技マルチプレイのロールバック / TAS・リプレイ

| 対応 | 内容 |
|------|------|
| **シミュレーション** | Rust に一本化。入力列 → Rust でフレーム単位に再実行 |
| **Elixir の役割** | マッチメイキング、入力収集、リプレイ記録の orchestration |

### 4.3 音ゲー的な BGM/SE 同期

| 対応 | 内容 |
|------|------|
| **音声のタイミング** | Rust 側でゲームループと共有のタイムベースを持つ |
| **Elixir の役割** | 「このタイミングで再生してほしい」というイベントを送るのみ。実際の再生タイミングは Rust が担当 |

### 4.4 設計の原則

**タイミングクリティカルなパスは Rust 内に閉じる**

```
【現在】 Elixir が tick を開始
  Process.send_after → :tick → physics_step NIF

【将来・リズム等】 Rust が tick を主導
  Rust 内ループ → 固定間隔で physics → イベントを Elixir に送信
```

---

## 5. やらなくていいもの

このエンジンのジャンル（バレットヘル・サバイバー系）および目的において、**対応不要と判断できる項目**をまとめる。

| 項目 | 理由 |
|------|------|
| **60Hz ジッター対策** | ±数 ms は許容範囲。実害が出るまで対応しない |
| **完全な ECS フレームワーク** | 現状の SoA + 手動設計で十分スケール。汎用 ECS は過剰 |
| **マルチプレイ** | サバイバー系は基本的にシングルプレイ。設計・実装コストが大きい |
| **ネットワーク機能（ランキング除く）** | 同上。リーダーボードが必要なら HTTP API で外付け |
| **マップ・タイル管理** | 「無限平面」というデザインを選んでいる限り必須ではない |
| **NIF オーバーヘッドの追加対策** | `get_frame_metadata` で十分なら、さらなる最適化は不要 |

### デザイン次第のもの

| 項目 | 備考 |
|------|------|
| **セーブ・ロード** | セッション単位のプレイなら不要。ハイスコア・アンロックの永続化が必要なら検討 |
| **Skeleton, Ghost, Garlic 等** | ゲームコンテンツの追加。エンジン基盤の必須要件ではない |

---

## 6. 設計上の原則

1. **タイミングクリティカルなパスは Rust 内に閉じる**
   - ゲームループ tick、physics、描画、音声の同期は Rust が担当

2. **Elixir は orchestration とロジックに専念**
   - ウェーブ、ボス、シーン遷移、EventBus、Stats、Telemetry など

3. **将来の拡張は Rust 主導モードの追加で対応**
   - 現状の Elixir 主導モードは維持しつつ、必要になったら Rust 主導の「精度モード」を追加

4. **「やらなくていい」と判断したものは手を入れない**
   - 実害が出るまで対応しない。必要になったら再検討する

---

## 関連ドキュメント

| ドキュメント | 用途 |
|-------------|------|
| [WHY_ELIXIR.md](./WHY_ELIXIR.md) | Elixir 採用の技術的根拠 |
| [ENGINE_ANALYSIS_REVISED.md](../02_spec_design/ENGINE_ANALYSIS_REVISED.md) | エンジン現状の評価 |
