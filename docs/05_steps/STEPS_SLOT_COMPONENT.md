# Slot・コンポーネント設計ステップガイド（Step 55〜61）

**目的**: [STEPS_3D.md](./STEPS_3D.md)（Step 48〜54）完了後、**Slot（transform 階層）＋ Component（カメラ・プレイヤー・敵・メッシュ等）を Elixir 側で管理**する設計に移行する。将来的なビジュアルエディタを見据え、シーングラフ・コンポーネント型・シリアライズ・Prefab の概念を実装に落とす。  
**前提**: Step 48〜54 まで完了（3D レンダリング・三人称 FPS が動作）。本ステップで「正本を Elixir の Slot/Component に移し、Rust はシーンスナップショットを受け取って描画する」形にリファクタする。

---

## 目次

1. [全体ロードマップ](#1-全体ロードマップ)
2. [Step 55: Slot（transform 階層）のデータ構造](#2-step-55-slottransform-階層のデータ構造)
3. [Step 56: コンポーネント型・レジストリと Slot への付与](#3-step-56-コンポーネント型レジストリと-slot-への付与)
4. [Step 57: ワールド行列計算・シーンスナップショット・Rust 連携](#4-step-57-ワールド行列計算シーンスナップショットrust-連携)
5. [Step 58: 物理結果の Rust → Elixir 反映（Slot 同期）](#5-step-58-物理結果の-rust--elixir-反映slot-同期)
6. [Step 59: シーンシリアライズ・保存/ロード](#6-step-59-シーンシリアライズ保存ロード)
7. [Step 60: Prefab とインスタンス](#7-step-60-prefab-とインスタンス)
8. [Step 61: ビジュアルエディタ向け基盤](#8-step-61-ビジュアルエディタ向け基盤)
9. [推奨実施順序と依存関係](#9-推奨実施順序と依存関係)
10. [関連ドキュメント](#10-関連ドキュメント)

---

## 1. 全体ロードマップ

```
Step 55: Slot（transform 階層）のデータ構造
  └ Elixir で id / parent_id / local_transform を管理

Step 56: コンポーネント型・レジストリと Slot への付与
  └ Camera, Player, Enemy, Mesh 等の型定義と Slot への付与

Step 57: ワールド行列計算・シーンスナップショット・Rust 連携
  └ 毎フレーム Elixir がワールド行列を計算し、Rust に渡して描画

Step 58: 物理結果の Rust → Elixir 反映（Slot 同期）
  └ 物理ステップの結果で Slot の位置を更新

Step 59: シーンシリアライズ・保存/ロード
  └ シーンファイル形式・バージョン・ロード

Step 60: Prefab とインスタンス
  └ 再利用可能な Slot サブツリー・インスタンス化とオーバーライド

Step 61: ビジュアルエディタ向け基盤
  └ コンポーネントスキーマ・選択・Undo の検討と最小実装
```

**目標**: シーンの「正本」が Elixir の Slot/Component になり、Rust は描画・物理の実行と結果の返却に専念する。ビジュアルエディタで同じデータを編集できる土台ができること。

---

## 2. Step 55: Slot（transform 階層）のデータ構造

### 2.1 目標

- **Slot** を Elixir のデータ構造として定義する。各 Slot は `id`、`parent_slot_id`（親）、`local_transform`（position, rotation, scale）を持つ。
- Slot の木構造を保持するストア（プロセス状態 or ETS）を用意し、追加・削除・親子変更ができるようにする。

### 2.2 なぜ重要か

- カメラ・プレイヤー・敵を「Slot に付くコンポーネント」で扱う土台。Unity の GameObject（EmptyObject）に相当するノードを Elixir で持つ。

### 2.3 責務分離

| レイヤー | 担当 |
|----------|------|
| **Elixir** | Slot の CRUD、親子関係、local_transform の保持と更新 |
| **Rust** | このステップでは未使用。Step 57 でスナップショットを受け取る |

### 2.4 実装内容

#### 55.1 Slot の構造

- `id`: 一意（UUID または整数）。ルート用の `nil` または固定 ID を 1 つ用意してもよい。
- `parent_slot_id`: 親 Slot の id。`nil` の場合はルート。
- `local_transform`: `%{position: {x, y, z}, rotation: {qx, qy, qz, qw} または {pitch, yaw, roll}, scale: {sx, sy, sz}}`。最小限は position のみでも可（rotation/scale は Step 57 で必要に応じて拡張）。

#### 55.2 ストア

- **SceneGraph** のような GenServer または ETS テーブルで、`slot_id => %Slot{}` を保持。
- `add_slot(parent_id, local_transform)`、`remove_slot(id)`、`set_local_transform(id, transform)`、`reparent(id, new_parent_id)` などの API。

#### 55.3 ツリーの整合性

- 親を削除したら子の扱い（子も削除するか、ルートに昇格するか）を決めておく。閉路ができないようにする。

### 2.5 確認ポイント

- [ ] Slot を追加・削除・親子変更・local_transform 更新できる
- [ ] ルートから任意の Slot まで木として辿れる
- [ ] 既存 3D ゲームはまだ Rust 側のままでも動作する（本ステップは並行して追加でよい）

---

## 3. Step 56: コンポーネント型・レジストリと Slot への付与

### 3.1 目標

- **コンポーネント型**（`:camera`、`:player`、`:enemy`、`:mesh` 等）を定義し、各型ごとの**プロパティ（スキーマ）**を決める。
- 各 Slot に「どのコンポーネントが付いているか」を紐づけ、プロパティを保持する。1 Slot に複数コンポーネント可。

### 3.2 なぜ重要か

- ビジュアルエディタの「Add Component」「Inspector でプロパティ編集」の前提。同じ型定義をランタイムとエディタで共有する。

### 3.3 責務分離

| レイヤー | 担当 |
|----------|------|
| **Elixir** | コンポーネント型のレジストリ、Slot へのコンポーネント付与・削除、プロパティの取得・更新 |
| **Rust** | まだコンポーネントを直接参照しない。Step 57 でスナップショットに「どの Slot に何が付いているか」が含まれる |

### 3.4 実装内容

#### 56.1 コンポーネント型レジストリ

- 型名（アトム）とプロパティのスキーマ（名前・型・デフォルト値）の対応。例: `%{camera: [fov: :float, near: :float, far: :float], player: [hp: :float, max_hp: :float], ...}`。
- モジュール属性や別モジュールで「利用可能なコンポーネント型一覧」を公開し、エディタの「Add Component」メニューや Inspector の生成に使う。

#### 56.2 Slot とコンポーネントの紐づけ

- ストアを拡張: `slot_id => [%Component{type: :camera, props: %{...}}, %Component{type: :mesh, props: %{...}}]` のように、Slot ごとにコンポーネントリストを持つ。
- `add_component(slot_id, type, props)`、`remove_component(slot_id, type)`、`set_component_props(slot_id, type, props)`。

#### 56.3 代表的なコンポーネント

- **Camera**: FOV, near, far 等。この Slot の world transform が View の基準になる（Step 57 で使用）。
- **Player**: HP, 装備等。入力でこの Slot を動かす対象。
- **Enemy**: HP, kind_id, AI 状態等。
- **Mesh**: アセット参照（mesh_id または path）、マテリアル参照等。この Slot の world transform でメッシュを描画する（Step 57 で使用）。

### 3.5 確認ポイント

- [ ] Slot に Camera / Player / Enemy / Mesh を付与・削除・プロパティ更新できる
- [ ] コンポーネント型の一覧とスキーマが一箇所で定義され、将来エディタから参照できる形になっている

---

## 4. Step 57: ワールド行列計算・シーンスナップショット・Rust 連携

### 4.1 目標

- Elixir で全 Slot の**ワールド行列**（local を親からたどって積算）を計算する。
- 毎フレーム（または Rust が要求するタイミング）で**シーンスナップショット**を組み立て、Rust に渡す。スナップショットには「カメラ Slot の world transform」「Mesh コンポーネントが付いた Slot の world transform とメッシュ参照」等を含める。
- Rust はスナップショットだけを見て描画する（カメラ行列の組み立て・メッシュの配置）。既存の「Rust 内で持っていたカメラ・プレイヤー位置」は、Elixir 由来のスナップショットに置き換える。

### 4.2 なぜ重要か

- 「正本は Elixir」を実現する。Rust は描画エンジンとして「渡されたシーンを描く」だけに徹する。

### 4.3 責務分離

| レイヤー | 担当 |
|----------|------|
| **Elixir** | ワールド行列の計算、スナップショットの組み立て、既存の `get_frame_metadata` 等の返りにスナップショットを載せる（または専用 NIF の引数として渡す） |
| **Rust** | スナップショットを受け取り、View/Projection（カメラ Slot から）、各メッシュの Model 行列（Mesh 付き Slot の world から）を組み立てて描画 |

### 4.4 実装内容

#### 57.1 ワールド行列の計算

- ルートから深さ優先で走査し、各 Slot の `world_transform`（4x4 行列または position + rotation + scale）を計算。親の world × 自分の local。
- 回転はクォータニオンまたはオイラー角で統一。Rust に渡す形式（行列の並び順・float 配列）を決める。

#### 57.2 シーンスナップショットの形式

- **camera**: Slot id と world transform（または View 行列を Elixir で計算して渡す）。FOV 等は Camera コンポーネントから。
- **meshes**: `[{slot_id, world_transform, mesh_ref, material_ref}, ...]`。Rust はこれだけ見て描画。
- 必要なら **lights** 等も将来拡張。

#### 57.3 Rust 側の変更

- 3D レンダラーが「フレームごとに渡されるスナップショット」を入力とし、内部のカメラ・オブジェクト位置をスナップショットで上書きする。既存の GameWorld 内の位置は、Step 58 で Slot に同期するまでは、Elixir が「プレイヤー Slot の world を GameWorld に書き戻す」などの橋渡しをしてもよい。

### 4.5 確認ポイント

- [ ] Elixir でワールド行列が正しく計算される（親子を動かすと子の world が変わる）
- [ ] スナップショットを Rust に渡すと、カメラとメッシュがその通りに描画される
- [ ] 三人称 FPS のカメラ・プレイヤー・敵が、Slot/Component 由来のスナップショットで表示される

---

## 5. Step 58: 物理結果の Rust → Elixir 反映（Slot 同期）

### 5.1 目標

- **物理ステップ**（衝突・弾丸・重力等）はこれまでどおり Rust で実行する。Rust は「このフレームの入力（プレイヤー Slot の現在位置・入力状態、敵 Slot の現在位置等）」を受け取り、物理結果（新しい位置・速度）を返す。
- Elixir はその結果を受け取り、**対応する Slot の local_transform（または world）を更新**する。これで「位置の正本は Elixir の Slot」を保ちつつ、重い計算は Rust に任せる。

### 5.2 なぜ重要か

- Slot を正本にしたまま、既存の Rust 物理を活かす。Rust が「プレイヤー・敵の新しい位置」を返し、Elixir が Slot に反映する責務分離をはっきりさせる。

### 5.3 責務分離

| レイヤー | 担当 |
|----------|------|
| **Elixir** | 物理の「入力」として Slot の現在位置等を Rust に渡す。返却された新しい位置で Slot の transform を更新 |
| **Rust** | 物理ステップの実行。返り値に「更新すべき slot_id と新しい position（と必要なら rotation）」を含める |

### 5.4 実装内容

#### 58.1 物理入力

- プレイヤー Slot の world position、入力（WASD 等）を NIF に渡す。敵 Slot の world position 一覧を渡す。Rust はそれを使って physics_step を実行。

#### 58.2 物理出力

- NIF の返りに `player_new_position`、`enemies: [{slot_id, new_position}, ...]` 等を含める。Elixir は受け取って該当 Slot の `local_transform` を更新（親がある場合は world → local に逆算するか、Rust が local を返すかは設計次第）。

#### 58.3 親子関係との整合

- 物理で動かすのは「ルートに近い Slot」だけにし、子は親の transform で一緒に動く形にするか、または物理対象は常にルート直下の Slot に限定するなど、ルールを決めておく。

### 5.5 確認ポイント

- [ ] 物理ステップ後にプレイヤー・敵の Slot の位置が更新されている
- [ ] 描画は Step 57 のスナップショットのまま、Slot の更新がそのまま画面に反映される
- [ ] 衝突・弾丸のヒット等が従来どおり動作する

---

## 6. Step 59: シーンシリアライズ・保存/ロード

### 6.1 目標

- **シーンファイル**の形式を決める。Slot の木構造と各 Slot の local_transform、各 Slot に付いたコンポーネントの型とプロパティを、ファイル（JSON、MessagePack、独自バイナリ等）に保存し、ロードで復元できるようにする。
- **バージョン**を付与し、フォーマット変更時に互換性を考慮できるようにする。

### 6.2 なぜ重要か

- ビジュアルエディタで編集したシーンを保存し、ランタイムで同じデータをロードする前提。保存/ロードがなければエディタとゲームの往復ができない。

### 6.3 責務分離

| レイヤー | 担当 |
|----------|------|
| **Elixir** | シーングラフ＋コンポーネントをシリアライズしてファイルに書き出す。ファイルを読み込んでデシリアライズし、ストアを復元する |
| **Rust** | シリアライズ形式には関与しない。アセット参照（メッシュ ID 等）は Elixir が解決し、スナップショットに含めて渡す |

### 6.4 実装内容

#### 59.1 フォーマット

- 例: `%{version: 1, slots: [%{id: ..., parent_id: ..., local_transform: ...}, ...], components: %{slot_id => [%{type: :camera, props: ...}, ...]}}` を JSON 化。日付やメタデータ（シーン名等）を入れてもよい。

#### 59.2 保存

- 現在の SceneGraph をそのままシリアライズして書き出し。パスは `scenes/` 以下など、アセットと同様にルールを決める。

#### 59.3 ロード

- ファイルを読み、パースして Slot とコンポーネントを再構築。ID はそのまま復元するか、新規 ID を振り直すか方針を決める（Prefab インスタンス化と合わせて Step 60 で考慮してもよい）。

### 6.5 確認ポイント

- [ ] シーンを保存し、別セッションでロードすると同じ木・同じコンポーネントが復元される
- [ ] バージョン番号を入れておき、将来フォーマットを変えたときに分岐できる

---

## 7. Step 60: Prefab とインスタンス

### 7.1 目標

- **Prefab** を「複数 Slot とコンポーネントからなる再利用可能なサブツリーの定義」として扱う。保存形式は Step 59 のシーン形式の部分木でよい。
- **インスタンス化**: シーンまたはエディタで「Prefab を配置」すると、その定義をコピーした Slot サブツリーが生成される。インスタンスは「定義への参照＋オーバーライドしたプロパティだけ」を持ってもよい。

### 7.2 なぜ重要か

- 敵やアイテムを同じ定義から複数配置するために必要。ビジュアルエディタでも「Prefab をドラッグして配置」ができるようになる。

### 7.3 責務分離

| レイヤー | 担当 |
|----------|------|
| **Elixir** | Prefab 定義のロード・保持、インスタンス化（サブツリーのコピーと ID の振り直し）、オーバーライドの適用 |
| **Rust** | Prefab を直接知らなくてよい。スナップショットには「配置された結果の Slot」だけが含まれる |

### 7.4 実装内容

#### 60.1 Prefab 定義

- ファイルまたはメモリ上の「ルート Slot とその子孫」＋コンポーネント。形式は Step 59 のスロット列の部分集合。ルートの `parent_id` は未設定（インスタンス化時に親を指定する）。

#### 60.2 インスタンス化

- `instantiate_prefab(prefab_ref, parent_slot_id, world_position)` で、Prefab のルートを `parent_slot_id` の子として追加し、ルートの local_transform で位置を設定。子孫の ID は新規に振り直す。

#### 60.3 オーバーライド（任意）

- インスタンスごとに「この Slot のこのコンポーネントのこのプロパティだけ上書き」を保持。保存時は定義＋オーバーライドのみ保存し、ロード時にマージする。

### 7.5 確認ポイント

- [ ] Prefab を読み込み、シーンに複数インスタンスを配置できる
- [ ] インスタンスの位置を変えても他のインスタンスに影響しない
- [ ] （オプション）インスタンス単位のプロパティオーバーライドが保存・ロードで維持される

---

## 8. Step 61: ビジュアルエディタ向け基盤

### 8.1 目標

- ビジュアルエディタで同じ Slot/Component を編集するための**基盤**を整える。必ずしもフルエディタを完成させず、「エディタが使う概念とデータ形式をコード側で揃える」ところまでをステップとする。
- **コンポーネントスキーマの公開**（型一覧・プロパティ名・型・デフォルト）、**選択状態**（どの Slot が選択されているか）の扱い、**Undo/Redo** のための「変更をコマンドとして記録する」方針の検討と最小実装。

### 8.2 なぜ重要か

- エディタは「Elixir の Slot/Component を表示・編集するクライアント」と位置づける。スキーマが一箇所で定義され、エディタがそれを参照して Inspector を生成できるようにしておく。

### 8.3 責務分離

| レイヤー | 担当 |
|----------|------|
| **Elixir** | スキーマの提供（API またはファイル）、シーングラフの編集 API（エディタから呼ばれる）、Undo 用のコマンド履歴（オプション） |
| **エディタ** | 別アプリとして将来実装。Elixir の API を呼ぶか、シーンファイルを直接編集するかは未定。本ステップでは「エディタが前提とするデータ・API」を Elixir 側に用意する |

### 8.4 実装内容

#### 61.1 コンポーネントスキーマの公開

- 既存のレジストリを、エディタが取得できる形で公開する。例: `SceneGraph.list_component_types()` が `[%{type: :camera, props: [%{name: :fov, type: :float, default: 60.0}, ...]}, ...]` を返す。JSON で返す API や、静的ファイルとして export してもよい。

#### 61.2 選択状態（オプション）

- エディタが「現在選択している Slot」を Elixir に伝え、Elixir がそれを保持する。Gizmo の操作結果（移動・回転）を Elixir の `set_local_transform` に送る、という流れを想定。選択状態をどこに持つか（Elixir の GenServer、ETS、またはエディタ側のみ）は設計次第。

#### 61.3 Undo/Redo の検討

- 編集操作を「コマンド」（例: `{:set_transform, slot_id, old_value, new_value}`）として記録し、Undo で前の値に戻す。最小限は「直近 1 回の Undo」や、コマンドの型だけ定義して履歴は後で実装、でもよい。ドキュメントに「エディタではコマンド履歴を保持し、Undo 時に Elixir に逆操作を送る」と書いておくだけでもよい。

### 8.5 確認ポイント

- [ ] コンポーネント型とプロパティのスキーマが、コードの一箇所から取得できる
- [ ] （オプション）選択 Slot の更新や、単一コマンドの Undo が動く
- [ ] ドキュメントに「ビジュアルエディタが前提とする Slot/Component のデータ形式と API」がまとまっている

---

## 9. 推奨実施順序と依存関係

```
Step 55 → Step 56 → Step 57 → Step 58 → Step 59 → Step 60 → Step 61
```

- **55**: Slot がないとコンポーネントを載せられない。
- **56**: コンポーネントがないとスナップショットに「何を描画するか」を載せられない。
- **57**: スナップショットと Rust 連携で、描画の正本が Elixir になる。
- **58**: 物理と Slot を同期し、ゲームプレイが Slot ベースで一貫する。
- **59**: シーンをファイルにし、エディタとランタイムで共有する。
- **60**: Prefab で再利用と配置の効率化。
- **61**: エディタが使うスキーマ・選択・Undo の土台。

**前提**: Step 48〜54（STEPS_3D.md）完了。3D ゲームが既に動いている状態で、その「正本」を Slot/Component に移行する。

---

## 10. 関連ドキュメント

| ドキュメント | 用途 |
|-------------|------|
| [STEPS_3D.md](./STEPS_3D.md) | Step 48〜54。本ステップの前提（3D レンダリング・三人称 FPS） |
| [STEPS_ALL.md](./STEPS_ALL.md) | 全ステップ一覧（Step 55〜61 の概要） |
| [ENGINE_STRENGTHS_WEAKNESSES.md](../02_spec_design/ENGINE_STRENGTHS_WEAKNESSES.md) | エンジン適性・3D 目標 |
| [ELIXIR_RUST_DIVISION.md](../03_tech_decisions/ELIXIR_RUST_DIVISION.md) | Elixir/Rust 責務分離の原則 |

**設計メモ**: Slot と Component を Elixir で管理する方針、およびビジュアルエディタで使う概念（シーングラフ、コンポーネント型、スキーマ、Prefab、シリアライズ）は、会話で整理した内容を本ステップに反映している。必要に応じて `docs/06_system_design/` に `SLOT_COMPONENT_DESIGN.md` などの設計書を追加し、本ステップから参照してもよい。
