# ゲームエンジン分析: 強み・弱み・メリット・デメリット

> **📦 アーカイブ**  
> 本ドキュメントは 2026-02-23 時点の分析を保存しています。  
> **再評価版**（STEPS_PERF.md・PRIORITY_STEPS.md 導入後）は [ENGINE_ANALYSIS_REVISED.md](./ENGINE_ANALYSIS_REVISED.md) を参照してください。

**対象プロジェクト**: Elixir × Rust Survivor  
**アーキテクチャ**: Elixir (OTP ゲームロジック) + Rust (物理演算・GPU レンダリング) ハイブリッド  
**作成日**: 2026-02-23

---

## 目次

1. [アーキテクチャ概要](#1-アーキテクチャ概要)
2. [強み・メリット](#2-強みメリット)
3. [弱み・デメリット](#3-弱みデメリット)
4. [他エンジンとの比較](#4-他エンジンとの比較)
5. [ユースケース適性](#5-ユースケース適性)
6. [総合評価](#6-総合評価)

---

## 1. アーキテクチャ概要

```
┌─────────────────────────────────────────────────────────┐
│  Elixir / OTP レイヤー（ゲームロジック司令塔）            │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐  │
│  │GameLoop  │ │SpawnSys  │ │BossSys   │ │LevelSys  │  │
│  │(60Hz)    │ │(ウェーブ)│ │(ボス管理)│ │(レベルUP)│  │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘  │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐               │
│  │InputHdlr │ │StressMon │ │Stats     │               │
│  │(入力管理)│ │(性能監視)│ │(統計)    │               │
│  └──────────┘ └──────────┘ └──────────┘               │
│                    ↕ Rustler NIF (ResourceArc + Mutex) │
├─────────────────────────────────────────────────────────┤
│  Rust / ネイティブレイヤー（高性能コア）                  │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐  │
│  │Physics   │ │Renderer  │ │Audio     │ │Weapons   │  │
│  │(SoA ECS) │ │(wgpu GPU)│ │(rodio)   │ │(6種類)   │  │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘  │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐               │
│  │SpatialHash│ │Particles │ │Items     │               │
│  │(衝突判定)│ │(エフェクト)│ │(アイテム)│               │
│  └──────────┘ └──────────┘ └──────────┘               │
└─────────────────────────────────────────────────────────┘
```

---

## 2. 強み・メリット

### 2.1 パフォーマンス面

#### ✅ GPU インスタンシング描画
- 最大 **14,502 インスタンスを 1 draw call** で描画
- `wgpu` (WebGPU API) を使用したクロスプラットフォーム GPU レンダリング
- WGSL シェーダによる頂点・フラグメント処理
- スプライトアトラス (1600×64px) をバイナリ埋め込みで高速ロード

#### ✅ SoA (Structure of Arrays) ECS パターン
- `EnemyWorld`, `BulletWorld`, `ParticleWorld`, `ItemWorld` がすべて SoA レイアウト
- CPU キャッシュ効率が高く、SIMD 最適化が効きやすい
- フレームごとのヒープアロケーションを最小化（スロット再利用）

#### ✅ 空間ハッシュ衝突判定
- `FxHashMap` ベースの空間ハッシュ（セルサイズ 80px）
- O(n²) の全対全衝突を O(1) に近い計算量へ削減
- `query_nearby_into()` でバッファ再利用（アロケーションなし）

#### ✅ rayon による並列 AI 計算
- 全敵の Chase AI を `rayon::into_par_iter()` でデータ並列化
- マルチコア CPU を自動活用
- 敵数が増えても線形スケールに近い性能

#### ✅ Rust の低レベル最適化
- `opt-level = 3` + `lto = true` + `codegen-units = 1` でリリースビルド最大最適化
- 二乗距離比較で `sqrt()` を回避
- `dt.min(0.05)` キャップによる物理発散防止
- LCG 自作乱数生成器（標準ライブラリより軽量）

#### ✅ DirtyCpu NIF スケジューラ
- `physics_step` は `DirtyCpu` スケジューラで実行
- BEAM VM のスケジューラをブロックせず、他の Elixir プロセスへの影響を最小化

---

### 2.2 信頼性・耐障害性面

#### ✅ OTP Supervisor による自動復旧
- `one_for_one` 戦略で 6 つの GenServer を監視
- クラッシュしたプロセスのみ自動再起動
- ゲームループ・入力ハンドラ・監視システムが独立して動作

#### ✅ Elixir のプロセス分離
- 各システム（スポーン・ボス・レベルアップ・統計）が独立したプロセス
- 一つのシステムの障害が他に波及しない
- メッセージパッシングによる疎結合設計

#### ✅ 音声のグレースフルデグレード
- 音声デバイスが存在しない環境（CI、ヘッドレスサーバー等）では `None` を返して継続動作
- ゲームロジックへの影響なし

#### ✅ ResourceArc + Mutex による安全な共有
- Rust 側のゲームワールドを `ResourceArc<Mutex<GameWorldInner>>` で管理
- Rust の所有権システムによりデータ競合を型レベルで防止

---

### 2.3 開発体験・保守性面

#### ✅ 言語特性の役割分担が明確
- **Elixir**: ゲームロジック・ウェーブ制御・ボス管理（宣言的・関数型）
- **Rust**: 物理演算・描画・音声（高性能・型安全）
- 各レイヤーを独立して開発・テスト可能

#### ✅ Elixir の表現力豊かなゲームロジック
- パターンマッチによるゲームフェーズ分岐（`:playing`, `:level_up`, `:boss_alert`, `:game_over`）
- 純粋関数設計の `SpawnSystem`, `LevelSystem`（副作用なし・テスト容易）
- 宣言的なボススケジュール定義（時刻とボス種別のリスト）

#### ✅ ホットリロードの可能性
- Elixir コードは BEAM VM 上で動的更新が可能
- ゲームロジック（ウェーブ設定・ボス出現タイミング等）をゲーム実行中に変更できる潜在能力

#### ✅ スタンドアロン実行バイナリの存在
- `game_window` バイナリで Elixir なしに純 Rust で動作確認可能
- Rust 側の開発・デバッグサイクルが高速

#### ✅ 組み込みパフォーマンス監視
- `StressMonitor` が 1 秒ごとにフレーム予算超過を自動検出・ログ出力
- ASCII プログレスバー付きダッシュボード
- `Stats` GenServer でセッション統計を自動収集

#### ✅ クロスプラットフォーム対応
- `wgpu` により Windows / macOS / Linux / Web (WebGPU) で動作
- `winit` によるクロスプラットフォームウィンドウ管理

---

### 2.4 スケーラビリティ面

#### ✅ 分散システムへの拡張性
- Elixir/OTP の設計思想により、マルチノード分散への拡張が可能
- 将来的なマルチプレイヤー対応の基盤として機能しうる
- Phoenix Channels との統合でリアルタイム通信を追加可能

#### ✅ ゲームロジックの水平スケール
- 複数のゲームインスタンスを同一 BEAM VM 上で並列実行可能
- サーバーサイドゲームロジックとして活用できる

---

## 3. 弱み・デメリット

### 3.1 パフォーマンス面

#### ❌ NIF 呼び出しオーバーヘッド
- Elixir → Rust の NIF 呼び出しごとに Erlang Term ↔ Rust 型変換コストが発生
- `get_render_data()` は毎フレーム大量のデータを Elixir 側に返す設計
- 現在の実装では描画データを Elixir 経由で受け渡す必要があり、ゼロコピーではない

#### ❌ `find_nearest_enemy` が O(n) 線形探索
- Magic Wand の照準計算が毎フレーム全敵をループ
- 空間ハッシュを活用していない
- 敵数 1000 体以上でボトルネックになる可能性

#### ❌ Lightning チェーン探索も O(n)
- 連鎖先の探索が毎チェーンごとに全敵ループ
- 最大 6 チェーン × 全敵数 = 潜在的なボトルネック

#### ❌ 60Hz ゲームループの精度
- `Process.send_after/3` は Erlang スケジューラの都合で ±数ms のジッターが発生
- 高精度タイマーが必要なゲームには不向き
- 物理演算の決定論的再現性に影響する可能性

#### ❌ Mutex によるシリアル化
- `GameWorld(Mutex<GameWorldInner>)` により、NIF 呼び出しがシリアル化
- 複数の Elixir プロセスから同時にゲームワールドを操作できない

---

### 3.2 開発体験・保守性面

#### ❌ ビルド複雑性
- Elixir + Rust のデュアルビルドシステム（mix + cargo）
- `mix compile` が Rust のクロスコンパイルを自動実行するが、初回ビルドが遅い
- 音声ファイルは事前に `python assets/audio/gen_audio.py` を実行する必要がある
- 依存関係が 2 言語にまたがり、バージョン管理が複雑

#### ❌ デバッグの困難さ
- Elixir と Rust をまたぐバグのトレースが難しい
- NIF クラッシュは BEAM VM ごとクラッシュさせる（`DirtyCpu` でも完全には防げない）
- Rust 側のパニックが Elixir のスタックトレースに表示されない

#### ❌ テストコードの欠如
- `test/` ディレクトリが存在しない
- NIF 関数の単体テストが困難（Rust 側と Elixir 側の両方でテストが必要）
- 物理演算の回帰テストがない

#### ❌ `main.rs` と `lib.rs` の重複
- スタンドアロンバイナリ (`main.rs`) と NIF (`lib.rs`) でゲームロジックが重複している可能性
- 1628行の `main.rs` と 1683行の `lib.rs` が並存し、同期コストが高い

#### ❌ 型システムの境界での情報損失
- Rust の豊富な型情報（enum 等）が NIF 境界で文字列やアトムに変換される
- `spawn_enemies(world, kind, count)` の `kind` は文字列で渡される

---

### 3.3 機能面

#### ❌ 完全な ECS フレームワークではない
- SoA パターンを手動実装しているが、`bevy_ecs` や `hecs` のような汎用 ECS ではない
- エンティティ間の関係（親子・グループ）を表現する仕組みがない
- コンポーネントの動的追加・削除ができない

#### ❌ シーン管理システムの欠如
- ゲームフェーズはハードコードされた enum で管理
- 汎用的なシーン遷移・スタック管理がない
- 複数のゲームモード（ステージ選択・設定画面等）への拡張が困難

#### ❌ マップ・タイル管理がない
- 現在の実装は無限平面のみ
- 障害物・壁・タイルマップの概念がない
- 仕様書に記載のある Ghost（壁すり抜け）は実装不可能な状態

#### ❌ セーブ・ロード機能がない
- ゲーム状態の永続化機能なし
- ハイスコア・実績の保存ができない

#### ❌ 未実装の仕様
- Skeleton・Ghost 敵タイプ（仕様書に記載あり）
- Garlic 武器（仕様書に記載あり）
- 障害物システム
- ポーズ機能（ESC キーは仕様書に記載あり）

#### ❌ UI/UX の制限
- `egui` による即時モード GUI は複雑なアニメーション付き UI に不向き
- カスタムフォント・リッチテキストの対応が限定的
- ローカライゼーション（多言語対応）の仕組みがない

---

### 3.4 スケーラビリティ面

#### ❌ 単一ウィンドウ・単一プレイヤー前提
- 現在の設計はシングルプレイヤー専用
- マルチプレイヤー対応には `GameWorld` の設計変更が必要

#### ❌ 音声の制限
- `rodio` は基本的な BGM/SE 再生のみ
- 3D 音響・HRTF・DSP エフェクトの対応なし
- 音声ミキサー・音量フェードの細かい制御が限定的

#### ❌ アセット管理システムの欠如
- スプライトアトラスは `include_bytes!` でバイナリ埋め込み
- 実行時のアセット動的ロード・アンロードができない
- 大規模ゲームへのスケールアップが困難

#### ❌ ネットワーク機能がない
- オンラインマルチプレイ・ランキング・実績連携の仕組みがない
- Elixir の強みであるネットワーク機能が活用されていない

---

## 4. 他エンジンとの比較

| 観点 | 本プロジェクト | Unity | Bevy (Rust) | Godot |
|---|---|---|---|---|
| **パフォーマンス** | ★★★★☆ | ★★★☆☆ | ★★★★★ | ★★★☆☆ |
| **耐障害性** | ★★★★★ | ★★☆☆☆ | ★★★☆☆ | ★★★☆☆ |
| **開発速度** | ★★☆☆☆ | ★★★★★ | ★★★☆☆ | ★★★★☆ |
| **エコシステム** | ★★☆☆☆ | ★★★★★ | ★★★★☆ | ★★★★☆ |
| **スケーラビリティ** | ★★★★☆ | ★★★☆☆ | ★★★★☆ | ★★★☆☆ |
| **学習の容易さ** | ★☆☆☆☆ | ★★★☆☆ | ★★☆☆☆ | ★★★★☆ |
| **分散対応** | ★★★★★ | ★☆☆☆☆ | ★★☆☆☆ | ★★☆☆☆ |
| **デバッグ容易性** | ★★☆☆☆ | ★★★★★ | ★★★☆☆ | ★★★★☆ |

### Unity との比較
- **本プロジェクトの優位点**: Rust による型安全性・メモリ安全性、OTP による耐障害性、オープンソース
- **Unity の優位点**: ビジュアルエディタ、巨大なアセットストア、モバイル対応、充実したドキュメント

### Bevy (純 Rust ECS) との比較
- **本プロジェクトの優位点**: Elixir によるゲームロジックの表現力、OTP の耐障害性、ホットリロード可能性
- **Bevy の優位点**: 本格的な ECS、豊富なプラグインエコシステム、単一言語の一貫性、活発なコミュニティ

### Godot との比較
- **本プロジェクトの優位点**: Rust による高性能コア、分散システムへの拡張性
- **Godot の優位点**: ビジュアルエディタ、GDScript の習得容易性、2D/3D 統合環境

---

## 5. ユースケース適性

### 向いているユースケース

| ユースケース | 適性 | 理由 |
|---|---|---|
| **サーバーサイドゲームロジック** | ★★★★★ | OTP の耐障害性・スケーラビリティが最大限活きる |
| **リアルタイムマルチプレイヤーゲーム** | ★★★★☆ | Phoenix Channels + Rust 物理演算の組み合わせが強力 |
| **大量エンティティのシミュレーション** | ★★★★☆ | SoA ECS + rayon 並列化 + 空間ハッシュの組み合わせ |
| **技術デモ・プロトタイプ** | ★★★★☆ | 2言語の組み合わせの可能性を実証するのに最適 |
| **バレットヘル・サバイバー系ゲーム** | ★★★★☆ | 現在の実装がまさにこのジャンル向けに最適化されている |

### 向いていないユースケース

| ユースケース | 適性 | 理由 |
|---|---|---|
| **3D ゲーム** | ★☆☆☆☆ | 3D レンダリング・物理演算の実装がない |
| **モバイルゲーム** | ★★☆☆☆ | タッチ入力・モバイル向け最適化がない |
| **大規模 RPG** | ★★☆☆☆ | シーン管理・セーブ機能・マップシステムがない |
| **インディーゲーム商業展開** | ★★☆☆☆ | エコシステム・ツールチェーンが未成熟 |
| **チーム開発** | ★★☆☆☆ | 2言語習得コストが高く、参入障壁が大きい |

---

## 6. 総合評価

### 技術的独自性

このプロジェクトは **「Elixir の耐障害性・表現力」と「Rust の高性能」を組み合わせる** という独自のアプローチを実証しています。既存のゲームエンジン（Unity, Godot, Bevy）にはない特徴として：

1. **OTP による本格的な耐障害性**: ゲームエンジンとして珍しい、プロダクションレベルの障害回復機能
2. **分散システムへの自然な拡張**: Elixir/OTP の設計思想により、マルチノード展開が他エンジンより容易
3. **ゲームロジックの宣言的記述**: Elixir の関数型パラダイムにより、ウェーブ・ボス・レベルアップロジックが読みやすい

### 現状の課題

現時点では **「技術実証デモ」の域を出ていない** 状況です：

- テストコードがない
- 仕様書との乖離（未実装機能が多数）
- `main.rs` と `lib.rs` の重複管理
- アセット管理・シーン管理などの基盤が未整備

### 推奨される改善方向

| 優先度 | 改善項目 |
|---|---|
| 高 | `find_nearest_enemy` / Lightning チェーンの空間ハッシュ化 |
| 高 | `main.rs` と `lib.rs` の共通ロジック統合 |
| 高 | 基本的なテストコードの追加 |
| 中 | アセット管理システムの設計 |
| 中 | シーン管理システムの導入 |
| 低 | マルチプレイヤー対応の設計検討 |

### 一言まとめ

> **「本番サービスの信頼性でゲームを動かす」という新しいアプローチの実証プロジェクト。パフォーマンスと耐障害性の組み合わせは独自の強みだが、汎用ゲームエンジンとしての完成度はまだ発展途上。**
